// Check for API URL environment variable
if (!process.env.NEXT_PUBLIC_API_URL) {
  console.warn('NEXT_PUBLIC_API_URL environment variable is not set. Using fallback URL.');
}

// Set the API URL with fallback
export const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'https://cou-ip-bkend-dev.vercel.app';
console.log('Initialized API_BASE_URL:', API_BASE_URL);

// Types
export interface JobRole {
  id: number;
  job_role_name: string;
  description: string | null;
  category_id: number;
  subcategory_id: number;
  active: boolean;
  created_at: string;
  created_by: number;
  updated_at: string | null;
  updated_by: number | null;
}

export interface Skill {
  id: number;
  skill_name: string;
  description: string | null;
  category_id: number;
  subcategory_id: number;
  active: boolean;
  created_at: string;
  created_by: number;
  updated_at: string | null;
  updated_by: number | null;
}

export interface CourseSubcategory {
  id: number;
  name: string;
  category_id: number;
  is_flagship: boolean;
  active: boolean;
  created_at: string;
  created_by: number | null;
  updated_at: string | null;
  updated_by: number | null;
}

export interface CourseCategory {
  id: number;
  name: string;
  is_flagship: boolean;
  is_IT: boolean;
  active: boolean;
  created_at: string;
  created_by: number | null;
  updated_at: string | null;
  updated_by: number | null;
}

export interface CreateJobRoleRequest {
  job_role_name: string;
  description?: string;
  category_id: number;
  subcategory_id: number;
  active: boolean;
  created_by: number;
}

export interface CreateSkillRequest {
  skill_name: string;
  description?: string;
  category_id: number;
  subcategory_id: number;
  active: boolean;
  created_by: number;
}

export interface CreateCourseSubcategoryRequest {
  name: string;
  category_id: number;
  is_flagship?: boolean;
  active?: boolean;
  created_by?: number;
}

export interface UpdateJobRoleRequest {
  job_role_name?: string;
  description?: string;
  category_id?: number;
  subcategory_id?: number;
  active?: boolean;
  updated_by: number;
}

export interface UpdateSkillRequest {
  skill_name?: string;
  description?: string;
  category_id?: number;
  subcategory_id?: number;
  active?: boolean;
  updated_by: number;
}

export interface UpdateCourseSubcategoryRequest {
  name?: string;
  category_id?: number;
  is_flagship?: boolean;
  active?: boolean;
  updated_by?: number;
}

// Define a type for the JSON data structure
export type OnboardingData = Record<string, unknown>;

// Onboarding Progress Types
export interface OnboardingProgress {
  session_id: string;  // UUID
  step_number: number;
  data: OnboardingData;  // JSON object
  user_id?: string | null;  // UUID
  created_at?: string;  // datetime
  updated_at?: string;  // datetime
}

export interface CreateOnboardingProgressRequest {
  session_id: string;           // Required - UUID generated by frontend
  step_number?: number | null;  // Optional
  data?: OnboardingData;        // Optional
  user_id?: string | null;      // Optional
}

export interface UpdateOnboardingProgressRequest {
  session_id: string;           // Should match URL parameter
  step_number?: number | null;  // Optional
  data?: OnboardingData;        // Optional
  user_id?: string | null;      // Optional
}

// Add additional properties to differentiate from the parent interface
export interface OnboardingProgressResponse extends OnboardingProgress {
  status?: string;              // Added to differentiate from parent interface
}

const API_ENDPOINTS = {
  health: {
    check: '/health'
  },
  courseCategories: {
    base: '/api/v1/coursecategories',
    getAll: '/api/v1/coursecategories',
    getById: (id: number) => `/api/v1/coursecategories/${id}`,
  },
  jobRoles: {
    base: '/api/v1/job-roles',
    getAll: '/api/v1/job-roles',
    getById: (id: number) => `/api/v1/job-roles/${id}`,
    create: '/api/v1/job-roles',
    update: (id: number) => `/api/v1/job-roles/${id}`,
    delete: (id: number) => `/api/v1/job-roles/${id}`,
  },
  skills: {
    base: '/api/v1/skills',
    getAll: '/api/v1/skills',
    getById: (id: number) => `/api/v1/skills/${id}`,
    create: '/api/v1/skills',
    update: (id: number) => `/api/v1/skills/${id}`,
    delete: (id: number) => `/api/v1/skills/${id}`,
  },
  courseSubcategories: {
    base: '/api/v1/coursesubcategories',
    getAll: '/api/v1/coursesubcategories',
    getById: (id: number) => `/api/v1/coursesubcategories/${id}`,
    create: '/api/v1/coursesubcategories',
    update: (id: number) => `/api/v1/coursesubcategories/${id}`,
    delete: (id: number) => `/api/v1/coursesubcategories/${id}`,
  },
  onboarding: {
    base: '/api/v1/onboarding',
    create: '/api/v1/onboarding',
    getBySessionId: (sessionId: string) => `/api/v1/onboarding/${sessionId}`,
    update: (sessionId: string) => `/api/v1/onboarding/${sessionId}`,
    delete: (sessionId: string) => `/api/v1/onboarding/${sessionId}`,
    getByUserId: (userId: string) => `/api/v1/onboarding/user/${userId}`,
    getAll: '/api/v1/onboarding',
    getProgress: '/api/v1/onboarding/:sessionId'
  }
};

// API response interface
interface ApiResponse<T> {
  data: T | null;
  error?: string;
  session_id?: string;
  step_number?: number;
  user_id?: string | null;
  created_at?: string;
  updated_at?: string;
}

// API Client
class OnboardingApiClient {
  private readonly DEFAULT_TIMEOUT = 15000; // 15 seconds
  private readonly MAX_RETRIES = 3;
  private readonly RETRY_DELAY = 2000; // 2 seconds
  private isHealthy: boolean = false;
  private lastHealthCheck: number = 0;
  private readonly HEALTH_CHECK_INTERVAL = 60000; // 1 minute

  private async fetchWithTimeout(
    url: string, 
    options: RequestInit, 
    timeout: number = this.DEFAULT_TIMEOUT
  ): Promise<Response> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const defaultOptions = {
        mode: 'cors' as RequestMode,
        credentials: 'include' as RequestCredentials,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        }
      };

      const mergedOptions = {
        ...defaultOptions,
        ...options,
        headers: {
          ...defaultOptions.headers,
          ...(options.headers || {})
        },
        signal: controller.signal,
      };

      console.log(`Making request to: ${url}`, {
        method: mergedOptions.method,
        headers: mergedOptions.headers,
        mode: mergedOptions.mode,
        credentials: mergedOptions.credentials
      });

      const response = await fetch(url, mergedOptions);
      
      // Log response status and headers
      console.log(`Response from ${url}:`, {
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries())
      });

      return response;
    } catch (error) {
      if (error instanceof Error) {
        // Enhance error message with request details
        const enhancedError = new Error(
          `Failed to fetch: ${error.message}\nURL: ${url}\nMethod: ${options.method}`
        );
        enhancedError.stack = error.stack;
        throw enhancedError;
      }
      throw error;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  // Add health check method
  async checkHealth(): Promise<boolean> {
    try {
      const now = Date.now();
      // Only check health if we haven't checked in the last minute
      if (now - this.lastHealthCheck < this.HEALTH_CHECK_INTERVAL && this.isHealthy) {
        return this.isHealthy;
      }

      console.log('Performing API health check...');
      const response = await this.fetchWithTimeout(
        `${API_BASE_URL}${API_ENDPOINTS.health.check}`,
        {
          method: 'GET',
          headers: {
            'Accept': 'application/json'
          },
          credentials: 'include',
          mode: 'cors'
        },
        5000 // Shorter timeout for health check
      );

      this.isHealthy = response.ok;
      this.lastHealthCheck = now;

      if (!this.isHealthy) {
        console.error('API health check failed:', {
          status: response.status,
          statusText: response.statusText
        });
      } else {
        console.log('API health check passed');
      }

      return this.isHealthy;
    } catch (error) {
      this.isHealthy = false;
      if (error instanceof Error) {
        console.error('Health check failed:', {
          message: error.message,
          stack: error.stack
        });
      }
      return false;
    }
  }

  // Modify fetchApi to handle 404s better
  private async fetchApi<T>(endpoint: string, options?: RequestInit): Promise<T | null> {
    // Skip health check for health endpoint to avoid infinite loop
    if (!endpoint.includes('/health')) {
      const isHealthy = await this.checkHealth();
      if (!isHealthy) {
        throw new Error('API is not healthy. Please try again later.');
      }
    }

    const url = `${API_BASE_URL}${endpoint}`;
    
    for (let attempt = 0; attempt <= this.MAX_RETRIES; attempt++) {
      try {
        console.log(`Attempting request to ${url}`, {
          attempt: attempt + 1,
          maxAttempts: this.MAX_RETRIES + 1,
          method: options?.method,
          endpoint,
          url: url
        });
        
        const response = await this.fetchWithTimeout(url, {
          ...options,
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            ...options?.headers,
          },
          credentials: 'include',
          mode: 'cors'
        });

        if (!response.ok) {
          const responseText = await response.text();
          let responseData;
          try {
            responseData = responseText ? JSON.parse(responseText) : null;
          } catch {
            responseData = responseText;
          }
          
          // Special handling for 404s
          if (response.status === 404) {
            console.log('Resource not found:', {
              url,
              method: options?.method,
              endpoint,
              responseData
            });
            return null;
          }
          
          console.error(`Request failed with status ${response.status}:`, {
            url,
            method: options?.method,
            status: response.status,
            statusText: response.statusText,
            responseData,
            attempt: attempt + 1
          });
          
          // Only retry on 5xx errors or network issues
          if (response.status >= 500 && attempt < this.MAX_RETRIES) {
            console.warn(`Server error (${response.status}), retrying...`);
            const delay = this.RETRY_DELAY * Math.pow(2, attempt);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          }
          
          throw new Error(responseData?.detail || `API request failed: ${response.status}`);
        }

        const responseText = await response.text();
        if (!responseText) {
          console.log('Empty response received');
          return null;
        }

        try {
          const parsedResponse = JSON.parse(responseText) as T;
          console.log('Successfully parsed response:', {
            url,
            method: options?.method,
            hasData: !!parsedResponse
          });
          return parsedResponse;
        } catch (e) {
          console.error('Failed to parse response:', {
            text: responseText,
            error: e instanceof Error ? e.message : 'Unknown error'
          });
          throw new Error('Invalid JSON response from server');
        }
      } catch (error) {
        if (error instanceof Error) {
          console.error('Request failed:', {
            url,
            attempt: attempt + 1,
            error: {
              message: error.message,
              name: error.name,
              stack: error.stack
            }
          });

          // Handle specific error types
          if (error.name === 'AbortError') {
            if (attempt < this.MAX_RETRIES) {
              console.warn('Request timeout, retrying...');
              const delay = this.RETRY_DELAY * Math.pow(2, attempt);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            }
            throw new Error(`Request timeout after ${this.MAX_RETRIES} retries`);
          }

          if (error.message.includes('CORS') || error.message.includes('cross-origin')) {
            console.error('CORS error detected:', {
              url,
              origin: window.location.origin,
              apiBaseUrl: API_BASE_URL
            });
            this.isHealthy = false;
            throw new Error(`CORS error: Unable to access ${API_BASE_URL}. Please check CORS configuration.`);
          }

          // Don't retry 404s
          if (error.message.includes('404') || error.message.includes('not found')) {
            return null;
          }

          if (attempt < this.MAX_RETRIES) {
            console.warn('Request failed, retrying...');
            const delay = this.RETRY_DELAY * Math.pow(2, attempt);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          }
        }
        throw error;
      }
    }

    throw new Error('Request failed after all retries');
  }

  // Add method to get API health status
  async getApiStatus(): Promise<{ 
    healthy: boolean; 
    lastCheck: Date | null;
    message: string;
  }> {
    const isHealthy = await this.checkHealth();
    return {
      healthy: isHealthy,
      lastCheck: this.lastHealthCheck ? new Date(this.lastHealthCheck) : null,
      message: isHealthy ? 'API is healthy' : 'API is not responding correctly'
    };
  }

  // Course Categories
  async getAllCourseCategories(): Promise<CourseCategory[]> {
    const response = await this.fetchApi<CourseCategory[]>(API_ENDPOINTS.courseCategories.getAll);
    if (!response) {
      return [];
    }
    return response;
  }

  async getCourseCategoryById(id: number): Promise<CourseCategory | null> {
    return this.fetchApi<CourseCategory>(API_ENDPOINTS.courseCategories.getById(id));
  }

  // Job Roles
  async getAllJobRoles(): Promise<JobRole[]> {
    const response = await this.fetchApi<JobRole[]>(API_ENDPOINTS.jobRoles.getAll);
    if (!response) {
      return [];
    }
    return response;
  }

  async getJobRoleById(id: number): Promise<JobRole | null> {
    return this.fetchApi<JobRole>(API_ENDPOINTS.jobRoles.getById(id));
  }

  async createJobRole(data: CreateJobRoleRequest): Promise<JobRole | null> {
    return this.fetchApi<JobRole>(API_ENDPOINTS.jobRoles.create, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async updateJobRole(id: number, data: UpdateJobRoleRequest): Promise<JobRole | null> {
    return this.fetchApi<JobRole>(API_ENDPOINTS.jobRoles.update(id), {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async deleteJobRole(id: number): Promise<JobRole | null> {
    return this.fetchApi<JobRole>(API_ENDPOINTS.jobRoles.delete(id), {
      method: 'DELETE',
    });
  }

  // Skills
  async getAllSkills(): Promise<Skill[]> {
    const response = await this.fetchApi<Skill[]>(API_ENDPOINTS.skills.getAll);
    if (!response) {
      return [];
    }
    return response;
  }

  async getSkillById(id: number): Promise<Skill | null> {
    return this.fetchApi<Skill>(API_ENDPOINTS.skills.getById(id));
  }

  async createSkill(data: CreateSkillRequest): Promise<Skill | null> {
    return this.fetchApi<Skill>(API_ENDPOINTS.skills.create, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async updateSkill(id: number, data: UpdateSkillRequest): Promise<Skill | null> {
    return this.fetchApi<Skill>(API_ENDPOINTS.skills.update(id), {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async deleteSkill(id: number): Promise<Skill | null> {
    return this.fetchApi<Skill>(API_ENDPOINTS.skills.delete(id), {
      method: 'DELETE',
    });
  }

  // Course Subcategories
  async getAllCourseSubcategories(): Promise<CourseSubcategory[]> {
    const response = await this.fetchApi<CourseSubcategory[]>(API_ENDPOINTS.courseSubcategories.getAll);
    if (!response) {
      return [];
    }
    return response;
  }

  async getCourseSubcategoryById(id: number): Promise<CourseSubcategory | null> {
    return this.fetchApi<CourseSubcategory>(API_ENDPOINTS.courseSubcategories.getById(id));
  }

  async createCourseSubcategory(data: CreateCourseSubcategoryRequest): Promise<CourseSubcategory | null> {
    return this.fetchApi<CourseSubcategory>(API_ENDPOINTS.courseSubcategories.create, {
      method: 'POST',
      body: JSON.stringify(data),
    });
  }

  async updateCourseSubcategory(
    id: number,
    data: UpdateCourseSubcategoryRequest
  ): Promise<CourseSubcategory | null> {
    return this.fetchApi<CourseSubcategory>(API_ENDPOINTS.courseSubcategories.update(id), {
      method: 'PUT',
      body: JSON.stringify(data),
    });
  }

  async deleteCourseSubcategory(id: number): Promise<CourseSubcategory | null> {
    return this.fetchApi<CourseSubcategory>(API_ENDPOINTS.courseSubcategories.delete(id), {
      method: 'DELETE',
    });
  }

  // Verify if a session exists
  private async verifySession(sessionId: string): Promise<boolean> {
    try {
      const progressResponse = await this.getOnboardingProgress(sessionId);
      return !!progressResponse.data;
    } catch (error) {
      if (error instanceof Error && error.message.includes('not found')) {
        return false;
      }
      throw error;
    }
  }

  // Get onboarding progress by session ID
  async getOnboardingProgress(sessionId: string): Promise<ApiResponse<OnboardingData>> {
    if (!sessionId) {
      throw new Error('sessionId is required for getting onboarding progress');
    }

    try {
      console.log('Fetching onboarding progress:', sessionId);
      const response = await this.fetchApi<OnboardingProgressResponse>(
        API_ENDPOINTS.onboarding.getBySessionId(sessionId),
        {
          method: 'GET',
          headers: {
            'Accept': 'application/json'
          }
        }
      );

      if (!response) {
        console.log('No session found, returning null response');
        return { data: null, error: 'Session not found' };
      }

      console.log('Successfully fetched onboarding progress:', {
        sessionId,
        step: response.step_number,
        hasData: !!response.data,
        hasUserId: !!response.user_id,
        createdAt: response.created_at,
        updatedAt: response.updated_at
      });

      return {
        data: response.data,
        session_id: response.session_id,
        step_number: response.step_number,
        user_id: response.user_id,
        created_at: response.created_at,
        updated_at: response.updated_at
      };
    } catch (error) {
      console.error('Failed to fetch onboarding progress:', {
        sessionId,
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack
        } : 'Unknown error'
      });
      
      if (error instanceof Error) {
        return { data: null, error: error.message };
      }
      return { data: null, error: 'Unknown error occurred' };
    }
  }

  // Utility method to validate UUID
  private isValidUuid(id: string): boolean {
    const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuidPattern.test(id);
  }

  // Update onboarding progress with verification and retry
  async updateOnboardingProgress(sessionId: string, data: UpdateOnboardingProgressRequest): Promise<OnboardingProgressResponse | null> {
    if (!sessionId) {
      throw new Error('sessionId is required for updating onboarding progress');
    }

    console.log('Starting onboarding progress update for session:', sessionId);

    try {
      // First, try to get existing session
      const existingSession = await this.getOnboardingProgress(sessionId).catch(error => {
        console.log('Error checking existing session:', {
          sessionId,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
        return null;
      });

      if (!existingSession) {
        // No session exists, create new one
        console.log('No existing session found, creating new:', sessionId);
        return await this.createOnboardingProgress({
          session_id: sessionId,
          step_number: data.step_number || 1,
          data: data.data || {},
          user_id: data.user_id
        });
      }

      // Session exists, update it
      console.log('Updating existing session:', {
        sessionId,
        currentStep: existingSession.step_number,
        newStep: data.step_number
      });

      return await this.fetchApi<OnboardingProgressResponse>(
        API_ENDPOINTS.onboarding.update(sessionId),
        {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            session_id: sessionId,
            step_number: data.step_number,
            data: data.data,
            user_id: data.user_id
          })
        }
      );
    } catch (error) {
      console.error('Failed to handle onboarding progress:', {
        sessionId,
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack
        } : 'Unknown error'
      });
      throw error;
    }
  }

  // Create onboarding progress
  async createOnboardingProgress(data: CreateOnboardingProgressRequest): Promise<OnboardingProgressResponse | null> {
    if (!data.session_id) {
      throw new Error('session_id is required for creating onboarding progress');
    }

    console.log('Creating onboarding progress:', {
      sessionId: data.session_id,
      step: data.step_number || 1,
      hasData: !!data.data,
      hasUserId: !!data.user_id
    });

    try {
      const response = await this.fetchApi<OnboardingProgressResponse>(
        API_ENDPOINTS.onboarding.create,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            session_id: data.session_id,
            step_number: data.step_number || 1,
            data: data.data || {},
            user_id: data.user_id
          })
        }
      );

      if (response) {
        console.log('Successfully created onboarding progress:', {
          sessionId: data.session_id,
          responseStep: response.step_number,
          responseUserId: response.user_id
        });
      }

      return response;
    } catch (error) {
      // Check if error is due to duplicate session
      if (error instanceof Error && 
          (error.message.includes('duplicate') || 
           error.message.includes('already exists'))) {
        console.log('Session already exists, fetching current state:', data.session_id);
        // Cast the API response to OnboardingProgressResponse to fix type compatibility
        const progress = await this.getOnboardingProgress(data.session_id);
        if (progress.data && progress.session_id) {
          return {
            session_id: progress.session_id,
            step_number: progress.step_number || 1,
            data: progress.data,
            user_id: progress.user_id,
            created_at: progress.created_at,
            updated_at: progress.updated_at
          } as OnboardingProgressResponse;
        }
        return null;
      }

      console.error('Failed to create onboarding progress:', {
        sessionId: data.session_id,
        error: error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack
        } : 'Unknown error'
      });
      throw error;
    }
  }

  // Get all onboarding progress
  async getAllOnboardingProgress(): Promise<OnboardingProgressResponse[]> {
    const response = await this.fetchApi<OnboardingProgressResponse[]>(API_ENDPOINTS.onboarding.getAll);
    if (!response) {
      return [];
    }
    return response;
  }

  // Get onboarding progress by user ID
  async getOnboardingProgressByUserId(userId: string): Promise<OnboardingProgressResponse[]> {
    if (!userId) {
      throw new Error('userId is required for getting onboarding progress');
    }

    const response = await this.fetchApi<OnboardingProgressResponse[]>(API_ENDPOINTS.onboarding.getByUserId(userId));
    if (!response) {
      return [];
    }
    return response;
  }

  // Delete onboarding progress
  async deleteOnboardingProgress(sessionId: string): Promise<void> {
    if (!sessionId) {
      throw new Error('sessionId is required for deleting onboarding progress');
    }

    await this.fetchApi<void>(API_ENDPOINTS.onboarding.delete(sessionId), {
      method: 'DELETE',
    });
  }
}

export const onboardingApiClient = new OnboardingApiClient(); 